// Generated by CoffeeScript 1.6.2
(function() {
  var app, async, balls, config, current, express, fade, fetch, fs, port, request, roundRobot, server, sphero, tasks, text, twit, twitter, _;

  express = require('express');

  app = express();

  server = require('http').createServer(app);

  fs = require('fs');

  async = require('async');

  request = require('request');

  _ = require('underscore');

  config = require('../config');

  roundRobot = require('node-sphero');

  sphero = new roundRobot.Sphero();

  twitter = require('ntwitter');

  twit = new twitter({
    consumer_key: config.twitter.consumerKey,
    consumer_secret: config.twitter.consumerSecret,
    access_token_key: config.twitter.accessTokenKey,
    access_token_secret: config.twitter.accessTokenSecret
  });

  tasks = [];

  text = [];

  current = {
    red: 0,
    blue: 0,
    green: 0
  };

  balls = [];

  sphero.on('connected', function(ball) {
    var requestInterval;

    ball.current = {
      red: 0,
      blue: 0,
      green: 0
    };
    ball.sentiment = {
      negative: 0,
      positive: 0,
      neutral: 0
    };
    balls.push(ball);
    console.log('CONNECTED ---> ', balls.length + ' sphero(s) connected');
    return requestInterval = setInterval(function() {
      return fetch();
    }, 5000);
  });

  fade = function(red, green, blue, speed, ball) {
    var fadeInterval, step;

    if (typeof requestInterval !== "undefined" && requestInterval !== null) {
      clearInterval(requestInterval);
    }
    speed = speed != null ? speed : 100;
    step = 0;
    return fadeInterval = setInterval(function() {
      var requestInterval;

      if (ball.current.red === red && ball.current.green === green && ball.current.blue === blue) {
        clearInterval(fadeInterval);
        requestInterval = setInterval(function() {
          return fetch();
        }, 5000);
      }
      if (ball.current.red < red) {
        ball.current.red++;
      } else if (ball.current.red > red) {
        ball.current.red--;
      }
      if (ball.current.green < green) {
        ball.current.green++;
      } else if (ball.current.green > green) {
        ball.current.green--;
      }
      if (ball.current.blue < blue) {
        ball.current.blue++;
      } else if (ball.current.blue > blue) {
        ball.current.blue--;
      }
      if (step === 3) {
        step = 0;
        ball.setRGBLED(ball.current.red, ball.current.green, ball.current.blue, false);
      }
      return step++;
    }, speed);
  };

  fetch = function() {
    var i, t, _fn, _i;

    _fn = function(t) {
      return tasks.push(function(cb) {
        return request('http://access.alchemyapi.com/calls/text/TextGetTextSentiment?apikey=' + config.alchemy.apiKey + '&outputMode=json&text=' + t, function(err, response, body) {
          var randomBall, res;

          res = JSON.parse(body);
          console.log(res);
          if (res.status === 'ERROR' || res.docSentiment.type === 'neutral') {
            cb();
            return;
          }
          randomBall = balls[Math.floor(Math.random() * balls.length)];
          randomBall.sentiment = {
            negative: 0,
            positive: 0,
            neutral: 0
          };
          randomBall.sentiment[res.docSentiment.type]++;
          return cb();
        });
      });
    };
    for (i = _i = 0; _i < 5; i = ++_i) {
      t = text[i];
      _fn(t);
    }
    return async.series(tasks, function() {
      var ball, s, sort, _j, _ref;

      console.log('done');
      if (balls.length) {
        console.log(balls.length);
        for (i = _j = 0, _ref = balls.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
          sort = [];
          ball = balls[i];
          for (i in ball.sentiment) {
            sort.push([i, ball.sentiment[i]]);
          }
          sort.sort(function(a, b) {
            return a[1] - b[1];
          });
          sort.reverse();
          s = sort[0][0];
          console.log(sort);
          if (s === 'negative') {
            fade(255, 0, 0, 50, ball);
          } else if (s === 'neutral') {
            fade(255, 255, 255, 50, ball);
          } else {
            fade(0, 255, 0, 50, ball);
          }
        }
        text = [];
        return tasks = [];
      }
    });
  };

  twit.stream('statuses/sample', {}, function(stream) {
    return stream.on('data', function(data) {
      return text.push(data.text);
    });
  });

  sphero.connect();

  server.on('disconnect', function() {
    var i, _i, _ref, _results;

    console.log('DISCONNECT');
    _results = [];
    for (i = _i = 0, _ref = balls.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(balls[i].disconnect());
    }
    return _results;
  });

  port = process.env.PORT || 3000;

  server.listen(port, function() {
    console.log("Server running on port " + port);
    return console.log('waiting for Sphero to connect...');
  });

}).call(this);
