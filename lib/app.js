// Generated by CoffeeScript 1.6.2
(function() {
  var app, async, config, current, express, fs, models, passport, port, request, requestInterval, roundRobot, sentiment, server, sphero, tasks, text, twit, twitter, _;

  express = require('express');

  app = express();

  server = require('http').createServer(app);

  passport = require('passport');

  config = require('./config/config');

  fs = require('fs');

  async = require('async');

  request = require('request');

  _ = require('underscore');

  models = __dirname + '/models';

  fs.readdirSync(models).forEach(function(file) {
    return require(models + '/' + file);
  });

  require('./config/passport')(passport, config);

  require('./config/express')(app, passport);

  require('./config/routes')(app, passport);

  roundRobot = require('node-sphero');

  sphero = new roundRobot.Sphero();

  twitter = require('ntwitter');

  twit = new twitter({
    consumer_key: '8hGJaqkwHDwWvDRJfRxjg',
    consumer_secret: 'EG7QU6IQ492SJ93VKKdAsUYpQL3L955WY4mINjWmo',
    access_token_key: '121854213-5F2uJ8Ulu1xTXLy1qnwvG9PmWWkVvm0wXB0raHpS',
    access_token_secret: 'R3j49Sk5i0mpziJtK8ea39uUYTC2vfL6yK6OehHKZ7w'
  });

  sentiment = {
    negative: 0,
    positive: 0,
    neutral: 0
  };

  tasks = [];

  text = [];

  current = {
    red: 0,
    blue: 0,
    green: 0
  };

  requestInterval = false;

  sphero.on('connected', function(ball) {
    var fade, fadeTest, fetch, test, testInterval;

    console.log('CONNECTED');
    fade = function(red, green, blue, speed) {
      var fadeInterval, step;

      clearInterval(requestInterval);
      speed = speed != null ? speed : 100;
      step = 0;
      return fadeInterval = setInterval(function() {
        if (current.red === red && current.green === green && current.blue === blue) {
          clearInterval(fadeInterval);
          requestInterval = setInterval(function() {
            return fetch();
          }, 5000);
        }
        console.log(current.red, current.green, current.blue);
        if (current.red < red) {
          current.red++;
        } else if (current.red > red) {
          current.red--;
        }
        if (current.green < green) {
          current.green++;
        } else if (current.green > green) {
          current.green--;
        }
        if (current.blue < blue) {
          current.blue++;
        } else if (current.blue > blue) {
          current.blue--;
        }
        if (step === 3) {
          step = 0;
          ball.setRGBLED(current.red, current.green, current.blue, false);
        }
        return step++;
      }, speed);
    };
    fetch = function() {
      var i, t, _fn, _i;

      _fn = function(t) {
        return tasks.push(function(cb) {
          return request('http://access.alchemyapi.com/calls/text/TextGetTextSentiment?apikey=c66401c4852d9fd88e7f66657056f3fabbb7680e&outputMode=json&text=' + t, function(err, response, body) {
            var res;

            res = JSON.parse(body);
            if (res.status === 'ERROR' || res.docSentiment.type === 'neutral') {
              cb();
              return;
            }
            sentiment[res.docSentiment.type]++;
            return cb();
          });
        });
      };
      for (i = _i = 0; _i < 5; i = ++_i) {
        t = text[i];
        _fn(t);
      }
      return async.series(tasks, function() {
        var s, sort;

        console.log('done');
        sort = [];
        for (i in sentiment) {
          sort.push([i, sentiment[i]]);
        }
        sort.sort(function(a, b) {
          return a[1] - b[1];
        });
        sort.reverse();
        s = sort[0][0];
        console.log(sort);
        if (s === 'negative') {
          fade(255, 0, 0, 50);
        } else if (s === 'neutral') {
          fade(255, 255, 255, 50);
        } else {
          fade(0, 255, 0, 50);
        }
        text = [];
        tasks = [];
        return sentiment = {
          negative: 0,
          positive: 0,
          neutral: 0
        };
      });
    };
    fadeTest = function(red, green, blue, speed) {
      var fadeInterval, step;

      speed = speed != null ? speed : 100;
      step = 0;
      return fadeInterval = setInterval(function() {
        var testInterval;

        if (current.red === red && current.green === green && current.blue === blue) {
          clearInterval(testInterval);
          testInterval = setInterval(function() {
            return fade(test[Math.floor(Math.random() * test.length)], test[Math.floor(Math.random() * test.length)], test[Math.floor(Math.random() * test.length)], 50);
          }, 1000);
        }
        console.log(current.red, current.green, current.blue);
        if (current.red < red) {
          current.red++;
        } else if (current.red > red) {
          current.red--;
        }
        if (current.green < green) {
          current.green++;
        } else if (current.green > green) {
          current.green--;
        }
        if (current.blue < blue) {
          current.blue++;
        } else if (current.blue > blue) {
          current.blue--;
        }
        if (step === 3) {
          step = 0;
          ball.setRGBLED(current.red, current.green, current.blue, false);
        }
        return step++;
      }, speed);
    };
    test = [255, 0];
    return testInterval = setInterval(function() {
      return fade(test[Math.floor(Math.random() * test.length)], test[Math.floor(Math.random() * test.length)], test[Math.floor(Math.random() * test.length)], 50);
    }, 1000);
  });

  sphero.connect();

  port = process.env.PORT || 1333;

  server.listen(port, function() {
    return console.log("Server running on port " + port);
  });

}).call(this);
